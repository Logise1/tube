<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shorts - Tube</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }

        /* Snap container */
        .shorts-container {
            height: 100vh;
            width: 100vw;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            scroll-behavior: smooth;
        }

        /* Hide scrollbar */
        .shorts-container::-webkit-scrollbar {
            display: none;
        }

        .shorts-container {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Individual Short Chunk */
        .short-item {
            height: 100vh;
            width: 100vw;
            scroll-snap-align: start;
            scroll-snap-stop: always;
            position: relative;
            background: #111;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Overlay Interface */
        .overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent 40%);
            padding: 20px;
            padding-bottom: 80px;
            /* Space for bottom nav check */
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            pointer-events: none;
        }

        /* Mobile Bottom Nav Spacer if needed? */
        /* Note: User usually has navbar on top or bottom. We'll keep a back button on top-left */

        .overlay-content {
            pointer-events: auto;
            max-width: 85%;
        }

        .actions {
            position: absolute;
            right: 16px;
            bottom: 100px;
            display: flex;
            flex-direction: column;
            gap: 24px;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }

        .action-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            background: none;
            border: none;
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            cursor: pointer;
        }

        .action-icon-bg {
            width: 48px;
            height: 48px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(4px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
        }

        .action-btn:active .action-icon-bg {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.2);
        }

        /* Navigation */
        .top-nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 16px;
            z-index: 50;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.6), transparent);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .play-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s, transform 0.2s;
        }

        .paused .play-icon {
            opacity: 1;
        }

        /* Comment Modal Animation */
        #comments-modal {
            transition: opacity 0.3s;
        }

        #comments-sheet {
            transition: transform 0.3s;
            transform: translateY(100%);
        }

        #comments-modal.open #comments-sheet {
            transform: translateY(0);
        }
    </style>
</head>

<body>

    <!-- Top Nav -->
    <div class="top-nav">
        <a href="index.html" class="p-2 rounded-full hover:bg-white/10 transition">
            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
            </svg>
        </a>
        <h1 class="font-bold text-lg tracking-wide">Shorts</h1>
        <button onclick="document.body.requestFullscreen().catch(console.log)"
            class="p-2 rounded-full hover:bg-white/10">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4">
                </path>
            </svg>
        </button>
    </div>

    <!-- Container -->
    <div class="shorts-container" id="shorts-container">
        <!-- Videos will be injected here -->
        <!-- Loading State -->
        <div class="h-screen w-full flex items-center justify-center bg-[#111]">
            <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-red-600"></div>
        </div>
        <!-- Comments Modal -->
        <div id="comments-modal" class="fixed inset-0 z-[60] hidden">
            <div class="absolute inset-0 bg-black/50" onclick="closeComments()"></div>
            <div id="comments-sheet"
                class="absolute bottom-0 w-full bg-[#1e1e1e] rounded-t-xl h-[60vh] flex flex-col text-white transform transition-transform duration-300">
                <div class="p-3 border-b border-[#333] flex justify-between items-center">
                    <h3 class="font-bold">Comentarios</h3>
                    <button onclick="closeComments()" class="p-1"><svg class="w-6 h-6" fill="none" stroke="currentColor"
                            viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"></path>
                        </svg></button>
                </div>
                <div id="comments-list" class="flex-1 overflow-y-auto p-4 space-y-4">
                    <!-- Comments -->
                </div>
                <div class="p-4 border-t border-[#333] bg-[#0f0f0f]">
                    <div class="flex gap-2">
                        <input type="text" id="comment-input" placeholder="Agrega un comentario..."
                            class="flex-1 bg-[#272727] text-white px-4 py-2 rounded-full outline-none focus:ring-1 focus:ring-blue-500 text-sm">
                        <button id="send-comment-btn"
                            class="bg-blue-600 p-2 rounded-full text-white hover:bg-blue-700"><svg class="w-5 h-5"
                                fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                            </svg></button>
                    </div>
                </div>
            </div>
        </div>

        <script>
            const API_BASE = 'https://aritube.logise1123.workers.dev/api';
            const token = localStorage.getItem('tubeclone_jwt_token');
            let currentVideoIdForComments = null;

            const container = document.getElementById('shorts-container');
            let videosData = [];

            async function init() {
                try {
                    // Fetch videos
                    const res = await fetch(`${API_BASE}/videos/all`);
                    if (!res.ok) throw new Error('Error al cargar');
                    const allVideos = await res.json();

                    // Filter shorts if tagged, OR just show random selection for demo if specific tag logic isn't fully populated yet in DB
                    // Logic: Check 'isShort' property or 'tags' array.
                    // Fallback: If no shorts found (legacy data), show *any* video as short but centered (crop-like effect)

                    let shorts = allVideos.filter(v => v.isShort === true || (v.tags && v.tags.includes('shorts')));

                    // Strict Mode: No fallback to all videos
                    // if (shorts.length === 0 && allVideos.length > 0) ... removed

                    if (shorts.length === 0) {
                        container.innerHTML = '<div class="h-screen flex items-center justify-center text-gray-500">No hay Shorts disponibles</div>';
                        return;
                    }

                    // Randomize for exploration
                    shorts.sort(() => Math.random() - 0.5);
                    videosData = shorts;

                    renderShorts(shorts);
                    setupObserver();

                } catch (e) {
                    console.error(e);
                    container.innerHTML = '<div class="h-screen flex items-center justify-center text-red-500">Error de conexión</div>';
                }
            }

            function renderShorts(videos) {
                container.innerHTML = videos.map((v, i) => `
                <div class="short-item" data-id="${v.id}" id="short-${i}">
                    <div class="video-wrapper relative w-full h-full">
                        <video 
                            data-src="${v.url}" 
                            data-segments='${JSON.stringify(v.segments || [])}'
                            data-mime="${v.mime || ''}"
                            loop 
                            playsinline 
                            poster="${v.thumbnail || ''}"
                            class="cursor-pointer w-full h-full object-cover"
                            onclick="togglePlay(this)"
                        ></video>
                        <!-- Custom Progress Bar -->
                        <div class="absolute bottom-0 left-0 w-full h-1 bg-gray-600/50 z-20">
                             <div class="h-full bg-red-600 progress-bar" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <div class="play-icon">
                         <svg class="w-10 h-10 text-white fill-current" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                    </div>

                    <div class="overlay">
                        <div class="overlay-content">
                            <div class="flex items-center gap-2 mb-3 cursor-pointer" onclick="window.location.href='profile.html?u=${v.userId}'">
                                <div class="w-10 h-10 rounded-full bg-gray-700 overflow-hidden border border-white">
                                    <div class="w-full h-full flex items-center justify-center bg-purple-600 text-lg font-bold">
                                        ${(v.userId || 'U')[0].toUpperCase()}
                                    </div>
                                </div>
                                <span class="font-bold text-shadow-md drop-shadow-md">@${v.userId || 'Usuario'}</span>
                                <button class="bg-red-600 text-white text-xs px-3 py-1 rounded-full font-bold ml-2 subscribe-btn" 
                                    onclick="handleSubscribe('${v.userId}', this, event)">Suscribirse</button>
                            </div>
                            <p class="mb-2 line-clamp-2 text-sm drop-shadow-md">${v.title}</p>
                            <p class="text-xs text-gray-300 drop-shadow-md">${v.description || ''}</p>
                        </div>
                    </div>

                    <div class="actions">
                        <button class="action-btn" onclick="handleLike('${v.id}', this)">
                            <div class="action-icon-bg hover:bg-white/20 transition">
                                <svg class="w-8 h-8 flex-shrink-0" fill="currentColor" viewBox="0 0 24 24"><path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-1.91l-.01-.01L23 10z"/></svg>
                            </div>
                            <span class="text-xs font-bold like-count">${kFormatter(v.likes || 0)}</span>
                        </button>

                        <button class="action-btn" onclick="openComments('${v.id}')">
                            <div class="action-icon-bg hover:bg-white/20 transition">
                                <svg class="w-8 h-8 flex-shrink-0" fill="white" viewBox="0 0 24 24"><path d="M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18z"/></svg>
                            </div>
                            <span class="text-xs font-bold">Coment.</span>
                        </button>

                        <button class="action-btn" onclick="navigator.share({title:'${v.title}', url: window.location.href})">
                            <div class="action-icon-bg hover:bg-white/20 transition">
                                <svg class="w-8 h-8 flex-shrink-0" fill="white" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/></svg>
                            </div>
                            <span class="text-xs font-bold">Compartir</span>
                        </button>
                    </div>
                </div>
            `).join('');

                // Trigger load for first few
                preloadVideo(0);
                preloadVideo(1);
            }

            function preloadVideo(index) {
                const el = document.getElementById(`short-${index}`);
                if (!el) return;
                const vid = el.querySelector('video');

                if (vid.src && vid.src.startsWith('blob:')) return; // Already MSE init
                if (vid.src && vid.currentSrc) return; // Already standard load

                const segments = JSON.parse(vid.dataset.segments || '[]');
                const mime = vid.dataset.mime;

                // Prioritize MSE if segments exist
                if (segments.length > 0 && mime && MediaSource.isTypeSupported(mime)) {
                    initMSE(vid, segments, mime);
                } else if (vid.dataset.src) {
                    // Fallback to standard
                    vid.src = vid.dataset.src;
                    vid.load();
                }
            }

            function initMSE(video, segments, mime) {
                const ms = new MediaSource();
                video.src = URL.createObjectURL(ms);

                ms.addEventListener('sourceopen', async () => {
                    const sb = ms.addSourceBuffer(mime);
                    sb.mode = 'sequence';

                    try {
                        const initRes = await fetch(segments[0]);
                        const initBuf = await initRes.arrayBuffer();
                        sb.appendBuffer(initBuf);

                        // Load next chunks immediately
                        if (segments.length > 1) {
                            await waitForUpdate(sb);
                            const chunkRes = await fetch(segments[1]);
                            sb.appendBuffer(await chunkRes.arrayBuffer());

                            // Load rest in background
                            loadRestSegments(sb, segments.slice(2));
                        }
                    } catch (e) { console.error('MSE Error', e); }
                });

                video.ontimeupdate = () => {
                    const bar = video.parentElement.querySelector('.progress-bar');
                    if (bar && video.duration) {
                        bar.style.width = (video.currentTime / video.duration) * 100 + '%';
                    }
                };
            }

            async function loadRestSegments(sb, urls) {
                for (const url of urls) {
                    if (sb.updating) await waitForUpdate(sb);
                    try {
                        const res = await fetch(url);
                        const buf = await res.arrayBuffer();
                        sb.appendBuffer(buf);
                    } catch (e) { break; }
                }
            }

            function waitForUpdate(sb) {
                return new Promise(resolve => {
                    if (!sb.updating) return resolve();
                    sb.addEventListener('updateend', function handler() {
                        sb.removeEventListener('updateend', handler);
                        resolve();
                    });
                });
            }

            // --- Logic for Infinite Scroll / Auto Play ---
            function setupObserver() {
                const options = {
                    root: container,
                    threshold: 0.6
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const video = entry.target.querySelector('video');
                        const index = parseInt(entry.target.id.split('-')[1]);

                        if (entry.isIntersecting) {
                            // Ensure src is set
                            preloadVideo(index);

                            // Play
                            resetAllVideos();
                            // For MSE, we might need to verify readyState
                            const playPromise = video.play();
                            if (playPromise) playPromise.catch(e => console.log('Autoplay prevented', e));

                            entry.target.classList.remove('paused');

                            // Preload neighbors
                            preloadVideo(index + 1);
                            preloadVideo(index - 1);

                            // Increment view count
                            if (!video.dataset.viewed && video.parentElement.dataset.id) {
                                video.dataset.viewed = "true";
                                fetch(`${API_BASE}/videos/details/${video.parentElement.dataset.id}`).catch(() => { });
                            }

                            cleanupDistantVideos(index);

                        } else {
                            video.pause();
                        }
                    });
                }, options);

                document.querySelectorAll('.short-item').forEach(el => observer.observe(el));
            }

            function cleanupDistantVideos(activeIndex) {
                document.querySelectorAll('.short-item').forEach(el => {
                    const index = parseInt(el.id.split('-')[1]);
                    if (Math.abs(index - activeIndex) > 1) {
                        const vid = el.querySelector('video');
                        if (vid.src) {
                            vid.removeAttribute('src'); // Unload
                            vid.load(); // Stop buffering
                        }
                    }
                });
            }

            function resetAllVideos() {
                document.querySelectorAll('video').forEach(v => v.pause());
            }

            window.togglePlay = function (videoEl) {
                const parent = videoEl.parentElement;
                if (videoEl.paused) {
                    videoEl.play();
                    parent.classList.remove('paused');
                } else {
                    videoEl.pause();
                    parent.classList.add('paused');
                }
            }

            function kFormatter(num) {
                return Math.abs(num) > 999 ? Math.sign(num) * ((Math.abs(num) / 1000).toFixed(1)) + 'k' : Math.sign(num) * Math.abs(num)
            }

            // Interactions
            async function handleLike(videoId, btn) {
                if (!token) return window.location.href = 'login.html';

                // Visual feedback
                const icon = btn.querySelector('svg');
                icon.classList.add('text-red-500', 'fill-current');

                try {
                    const res = await fetch(`${API_BASE}/videos/like/${videoId}`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    const data = await res.json();
                    if (data.success) {
                        btn.querySelector('.like-count').textContent = kFormatter(data.likes);
                    }
                } catch (e) { console.error(e); }
            }

            async function handleSubscribe(userId, btn, event) {
                event.stopPropagation();
                if (!token) return window.location.href = 'login.html';

                btn.disabled = true;
                btn.textContent = '...';

                try {
                    const res = await fetch(`${API_BASE}/videos/subscribe/${userId}`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    const data = await res.json();

                    if (data.success) {
                        btn.textContent = 'Suscrito';
                        btn.classList.replace('bg-red-600', 'bg-gray-700');
                        btn.classList.add('text-gray-300');
                    } else {
                        btn.textContent = 'Suscribirse';
                        btn.disabled = false;
                    }
                } catch (e) {
                    btn.textContent = 'Error';
                    btn.disabled = false;
                }
            }

            // Comments Logic
            function closeComments() {
                document.getElementById('comments-sheet').style.transform = 'translateY(100%)';
                setTimeout(() => document.getElementById('comments-modal').classList.add('hidden'), 300);
                currentVideoIdForComments = null;
            }

            async function openComments(videoId) {
                currentVideoIdForComments = videoId;
                const modal = document.getElementById('comments-modal');
                const sheet = document.getElementById('comments-sheet');
                const list = document.getElementById('comments-list');

                modal.classList.remove('hidden');
                // Force redraw for transition
                void modal.offsetWidth;
                sheet.style.transform = 'translateY(0)';

                list.innerHTML = '<div class="text-center py-4"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white mx-auto"></div></div>';

                try {
                    const res = await fetch(`${API_BASE}/comments/${videoId}`);
                    const comments = await res.json();

                    if (!comments || comments.length === 0) {
                        list.innerHTML = '<p class="text-gray-500 text-center py-10">Sé el primero en comentar.</p>';
                    } else {
                        list.innerHTML = comments.map(c => `
                        <div class="flex gap-3 items-start">
                            <div class="w-8 h-8 rounded-full bg-purple-600 flex-shrink-0 flex items-center justify-center text-xs font-bold">
                                ${(c.username || '?')[0].toUpperCase()}
                            </div>
                            <div>
                                <p class="text-xs text-gray-400 font-bold mb-0.5">@${c.username} <span class="font-normal text-gray-600 ml-2">${new Date(c.date).toLocaleDateString()}</span></p>
                                <p class="text-sm">${c.text}</p>
                            </div>
                        </div>
                    `).join('');
                    }
                } catch (e) {
                    list.innerHTML = '<p class="text-red-500 text-center">Error cargando comentarios.</p>';
                }
            }

            document.getElementById('send-comment-btn').onclick = async () => {
                if (!currentVideoIdForComments) return;
                if (!token) return window.location.href = 'login.html';

                const input = document.getElementById('comment-input');
                const text = input.value.trim();
                if (!text) return;

                input.value = '';

                try {
                    const res = await fetch(`${API_BASE}/comments`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify({ videoId: currentVideoIdForComments, text })
                    });

                    if (res.ok) {
                        // Refresh comments
                        openComments(currentVideoIdForComments);
                    }
                } catch (e) { alert('Error al comentar'); }
            };

            init();
        </script>
</body>

</html>